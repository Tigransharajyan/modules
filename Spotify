# meta developer: @shaatimi
# requires: spotipy aiohttp Pillow

from .. import loader, utils
import asyncio
from spotipy import Spotify
from spotipy.oauth2 import SpotifyOAuth
from PIL import Image
from io import BytesIO
import aiohttp
import os

@loader.tds
class SpotifyModule(loader.Module):
    strings_ru = {
        "name": "Spotify",
        "not_auth": "‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π .sauth",
        "auth_success": "‚úÖ –£—Å–ø–µ—à–Ω–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∫–∞–∫ {user}",
        "no_query": "‚ùå –£–∫–∞–∂–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞.",
        "not_found": "‚ùå –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        "current_track": "üéµ –°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç:\n<b>{name}</b>\n–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {artist}\n–ê–ª—å–±–æ–º: {album}",
        "client_set": "‚úÖ Client ID —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.",
        "secret_set": "‚úÖ Client Secret —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.",
        "redirect_set": "‚úÖ Redirect URI —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.",
        "missing_client": "‚ùå Client ID –∏–ª–∏ Secret –Ω–µ –∑–∞–¥–∞–Ω—ã.",
        "no_playback_device": "‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è.",
        "play_success": "‚úÖ –¢—Ä–µ–∫ –∑–∞–ø—É—â–µ–Ω –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ {device}"
    }

    strings = {
        "name": "Spotify",
        "not_auth": "‚ùå Not authorized. Use .sauth",
        "auth_success": "‚úÖ Successfully authorized as {user}",
        "no_query": "‚ùå Specify a track name.",
        "not_found": "‚ùå Track not found.",
        "current_track": "üéµ Now playing:\n<b>{name}</b>\nArtist: {artist}\nAlbum: {album}",
        "client_set": "‚úÖ Client ID set.",
        "secret_set": "‚úÖ Client Secret set.",
        "redirect_set": "‚úÖ Redirect URI set.",
        "missing_client": "‚ùå Client ID or Secret not set.",
        "no_playback_device": "‚ùå No active playback device found.",
        "play_success": "‚úÖ Track started on device {device}"
    }

    def __init__(self):
        self.sp = None
        self.user = None
        self.client_id = None
        self.client_secret = None
        self.redirect_uri = None
        self.device_id = None

    @loader.command()
    async def sclient(self, message):
        arg = utils.get_args_raw(message)
        if not arg:
            await utils.answer(message, "‚ùå –£–∫–∞–∂–∏ Client ID")
            return
        self.client_id = arg
        await utils.answer(message, self.strings["client_set"])

    @loader.command()
    async def ssecret(self, message):
        arg = utils.get_args_raw(message)
        if not arg:
            await utils.answer(message, "‚ùå –£–∫–∞–∂–∏ Client Secret")
            return
        self.client_secret = arg
        await utils.answer(message, self.strings["secret_set"])

    @loader.command()
    async def sredirect(self, message):
        arg = utils.get_args_raw(message)
        if not arg:
            await utils.answer(message, "‚ùå –£–∫–∞–∂–∏ Redirect URI")
            return
        self.redirect_uri = arg
        await utils.answer(message, self.strings["redirect_set"])

    @loader.command()
    async def sauth(self, message):
        if not self.client_id or not self.client_secret or not self.redirect_uri:
            await utils.answer(message, self.strings["missing_client"])
            return
        try:
            self.sp = Spotify(
                auth_manager=SpotifyOAuth(
                    client_id=self.client_id,
                    client_secret=self.client_secret,
                    redirect_uri=self.redirect_uri,
                    scope="user-read-playback-state user-modify-playback-state"
                )
            )
            me = await asyncio.to_thread(self.sp.current_user)
            self.user = me["display_name"]
            await utils.answer(message, self.strings["auth_success"].format(user=self.user))
        except Exception as e:
            await utils.answer(message, f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:\n<code>{e}</code>")

    @loader.command()
    async def sfind(self, message):
        if not self.sp:
            await utils.answer(message, self.strings["not_auth"])
            return
        query = utils.get_args_raw(message)
        if not query:
            await utils.answer(message, self.strings["no_query"])
            return
        try:
            results = await asyncio.to_thread(self.sp.search, query, type="track", limit=1)
            items = results.get("tracks", {}).get("items", [])
            if not items:
                await utils.answer(message, self.strings["not_found"])
                return
            track = items[0]
            name = track["name"]
            artist = ", ".join([a["name"] for a in track["artists"]])
            album = track["album"]["name"]
            url = track["external_urls"]["spotify"]
            img_url = track["album"]["images"][0]["url"]

            async with aiohttp.ClientSession() as session:
                async with session.get(img_url) as resp:
                    data = await resp.read()
                    image = BytesIO(data)
                    image.name = f"{name}.jpg"

            caption = f"<b>{name}</b>\n–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {artist}\n–ê–ª—å–±–æ–º: {album}\n<a href='{url}'>–û—Ç–∫—Ä—ã—Ç—å –≤ Spotify</a>"
            await message.client.send_file(message.chat_id, image, caption=caption, reply_to=message.reply_to_msg_id)

        except Exception as e:
            await utils.answer(message, f"‚ùå –û—à–∏–±–∫–∞:\n<code>{e}</code>")

    @loader.command()
    async def snow(self, message):
        if not self.sp:
            await utils.answer(message, self.strings["not_auth"])
            return
        try:
            track = await asyncio.to_thread(self.sp.current_user_playing_track)
            if not track or not track.get("item"):
                await utils.answer(message, "‚ùå –°–µ–π—á–∞—Å –Ω–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç –Ω–∞ –∞–∫—Ç–∏–≤–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.")
                return
            t = track["item"]
            name = t["name"]
            artist = ", ".join([a["name"] for a in t["artists"]])
            album = t["album"]["name"]
            url = t["external_urls"]["spotify"]
            img_url = t["album"]["images"][0]["url"]

            async with aiohttp.ClientSession() as session:
                async with session.get(img_url) as resp:
                    data = await resp.read()
                    image = BytesIO(data)
                    image.name = f"{name}.jpg"

            caption = self.strings["current_track"].format(name=name, artist=artist, album=album) + f"\n<a href='{url}'>–û—Ç–∫—Ä—ã—Ç—å –≤ Spotify</a>"
            await message.client.send_file(message.chat_id, image, caption=caption, reply_to=message.reply_to_msg_id)

        except Exception as e:
            await utils.answer(message, f"‚ùå –û—à–∏–±–∫–∞:\n<code>{e}</code>")

    @loader.command()
    async def splay(self, message):
        if not self.sp:
            await utils.answer(message, self.strings["not_auth"])
            return
        args = utils.get_args_raw(message)
        if not args:
            await utils.answer(message, "‚ùå –£–∫–∞–∂–∏ Spotify track URI –∏–ª–∏ ID")
            return
        try:
            devices = await asyncio.to_thread(self.sp.devices)
            if not devices["devices"]:
                await utils.answer(message, self.strings["no_playback_device"])
                return
            self.device_id = devices["devices"][0]["id"]
            await asyncio.to_thread(self.sp.start_playback, device_id=self.device_id, uris=[f"spotify:track:{args}"])
            await utils.answer(message, self.strings["play_success"].format(device=devices["devices"][0]["name"]))
        except Exception as e:
            await utils.answer(message, f"‚ùå –û—à–∏–±–∫–∞:\n<code>{e}</code>")
