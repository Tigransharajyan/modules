# meta developer: @shaatimi
# requires: spotipy aiohttp yt_dlp Pillow

from .. import loader, utils
import asyncio
import aiohttp
from io import BytesIO
from PIL import Image, ImageDraw, ImageFont
from yt_dlp import YoutubeDL
from spotipy import Spotify
from spotipy.oauth2 import SpotifyClientCredentials
import os

@loader.tds
class SpotifyDLModule(loader.Module):
    strings = {
        "name": "SpotifyDL",
        "no_query": "❌ Укажи название трека.",
        "not_found": "❌ Трек не найден.",
        "downloading": "⏳ Скачиваю трек: <b>{name}</b>",
        "sent": "✅ Трек отправлен",
        "not_auth": "❌ Используй .sauth для авторизации",
        "error": "❌ Ошибка:\n<code>{e}</code>",
    }

    def __init__(self):
        self.sp = None
        self.client_id = None
        self.client_secret = None

    @loader.command(ru_doc="Установить Client ID для Spotify API", en_doc="Set Spotify API Client ID")
    async def sclient(self, message):
        arg = utils.get_args_raw(message)
        if not arg:
            await utils.answer(message, "❌ Укажи Client ID")
            return
        self.client_id = arg
        await utils.answer(message, "✅ Client ID установлен.")

    @loader.command(ru_doc="Установить Client Secret для Spotify API", en_doc="Set Spotify API Client Secret")
    async def ssecret(self, message):
        arg = utils.get_args_raw(message)
        if not arg:
            await utils.answer(message, "❌ Укажи Client Secret")
            return
        self.client_secret = arg
        await utils.answer(message, "✅ Client Secret установлен.")

    @loader.command(ru_doc="Авторизация в Spotify через Client ID/Secret", en_doc="Authorize Spotify account")
    async def sauth(self, message):
        if not self.client_id or not self.client_secret:
            await utils.answer(message, "❌ Client ID или Secret не заданы.")
            return
        try:
            self.sp = Spotify(auth_manager=SpotifyClientCredentials(
                client_id=self.client_id,
                client_secret=self.client_secret
            ))
            await utils.answer(message, "✅ Авторизация пройдена.")
        except Exception as e:
            await utils.answer(message, self.strings["error"].format(e=e))

    @loader.command(ru_doc="Найти трек и прислать в Telegram с обложкой", en_doc="Find track and send to Telegram with cover")
    async def sfind(self, message):
        if not self.sp:
            await utils.answer(message, self.strings["not_auth"])
            return

        query = utils.get_args_raw(message)
        if not query:
            await utils.answer(message, self.strings["no_query"])
            return

        try:
            results = await asyncio.to_thread(self.sp.search, query, type="track", limit=1)
            items = results.get("tracks", {}).get("items", [])
            if not items:
                await utils.answer(message, self.strings["not_found"])
                return

            track = items[0]
            name = track["name"]
            artist = ", ".join([a["name"] for a in track["artists"]])
            album = track["album"]["name"]
            img_url = track["album"]["images"][0]["url"]
            yt_query = f"{name} {artist} audio"

            status = await utils.answer(message, self.strings["downloading"].format(name=name))

            file_name = f"track_{message.id}.m4a"
            ydl_opts = {
                "format": "bestaudio/best",
                "outtmpl": file_name,
                "quiet": True,
                "noplaylist": True,
            }

            with YoutubeDL(ydl_opts) as ydl:
                await asyncio.to_thread(ydl.extract_info, f"ytsearch1:{yt_query}", download=True)

            async with aiohttp.ClientSession() as session:
                async with session.get(img_url) as resp:
                    img_data = await resp.read()

            # Создаём карточку с обложкой
            img = Image.open(BytesIO(img_data)).convert("RGB")
            draw = ImageDraw.Draw(img)
            font = ImageFont.load_default()
            draw.rectangle([(0, img.height-40), (img.width, img.height)], fill=(0,0,0,180))
            draw.text((10, img.height-35), f"{name} - {artist}", font=font, fill="white")

            card = BytesIO()
            card.name = "cover.jpg"
            img.save(card, "JPEG")
            card.seek(0)

            await message.client.send_audio(
                chat_id=message.chat_id,
                audio=file_name,
                title=name,
                performer=artist,
                thumb=card,
                reply_to_message_id=message.reply_to_msg_id
            )

            await status.delete()
            if os.path.exists(file_name):
                os.remove(file_name)

        except Exception as e:
            await utils.answer(message, self.strings["error"].format(e=e))
